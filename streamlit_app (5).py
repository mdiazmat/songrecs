# -*- coding: utf-8 -*-
"""Streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ltfNFx21mhu8eXarFs_tf3eAvfnXuHzI
"""

import streamlit as st
import pandas as pd
import requests
import json
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors

# Groq API Key
GROQ_MODEL = "mixtral-8x7b"
GROQ_API_KEY = st.text_input("Enter your Groq API key:", type="password")

@st.cache_data
def load_data():
    return pd.read_csv("dataset.csv")

df = load_data()

# Defines Some of User's Playlists
@st.cache_data
def load_user_playlists():
    return {
        "R&B": df[(df['track_genre'].isin(['r-n-b'])) & (df['tempo'] >= 70) & (df['tempo'] <= 110) & (df['energy'] >= 0.3) & (df['energy'] <= 0.7)].sample(n=10, random_state=1),
        "Hype Rap": df[(df['track_genre'] == 'hip-hop') & (df['energy'] >= 0.7) & (df['tempo'] >= 90)].sample(n=10, random_state=2),
        "Beach Day": df[(df['track_genre'].isin(['reggae', 'latin', 'chill'])) & (df['valence'] >= 0.6) & (df['tempo'] >= 85)].sample(n=10, random_state=3),
        "Latin Workout": df[(df['track_genre'].isin(['latin', 'latino', 'reggaeton', 'salsa'])) & (df['energy'] >= 0.6) & (df['tempo'] >= 100)].sample(n=10, random_state=4),
        "Girly Pop": df[(df['track_genre'].isin(['pop', 'indie-pop', 'dance'])) & (df['valence'] >= 0.5)].sample(n=10, random_state=5),
        "Going Out": df[(df['track_genre'].isin(['party', 'dance', 'edm', 'club'])) & (df['energy'] >= 0.7) & (df['tempo'] >= 110)].sample(n=10, random_state=5),
        "Throwback Roadtrip": df[(df['track_genre'].isin(['rock', 'pop', 'rock-n-roll', 'indie'])) & (df['valence'] >= 0.5) & (df['tempo'] >= 90)].sample(n=10, random_state=4),
        "Chill Study": df[(df['track_genre'].isin(['chill', 'ambient', 'study', 'acoustic'])) & (df['energy'] <= 0.5)].sample(n=10, random_state=3),
        "Date Night": df[(df['track_genre'].isin(['romance', 'r-n-b', 'soul'])) & (df['tempo'] <= 100) & (df['valence'] >= 0.4) & (df['energy'] <= 0.6)].sample(n=10, random_state=3),
        "90s Hip-Hop": df[(df['track_genre'] == 'hip-hop') & (df['tempo'] < 100) & (df['valence'] <= 0.5)].sample(n=10, random_state=2),
        "Latino Cleaning": df[(df['track_genre'].isin(['latino', 'salsa', 'reggaeton'])) & (df['tempo'] >= 100) & (df['valence'] >= 0.6)].sample(n=10, random_state=1)
    }

user_playlists = load_user_playlists()

# Groq Prompt/Rules

# Find song features based off prompt
def get_feature_rules_from_prompt(prompt):
    system_prompt = (
        "You are a music playlist assistant. Based on the user's mood or request, return filtering rules "
        "in JSON format using audio features: valence, energy, tempo, danceability, acousticness. "
        "Use <, >, or ranges (like 0.2-0.4) to describe values. Example:\n"
        '{"valence": "< 0.3", "energy": "< 0.5", "tempo": "< 90"}'
    )

    url = "https://api.groq.com/openai/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": GROQ_MODEL,
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": prompt}
        ],
        "temperature": 0
    }

    response = requests.post(url, headers=headers, json=data)
    if response.status_code == 200:
        content = response.json()["choices"][0]["message"]["content"].strip()
        return json.loads(content)
    else:
        st.error("Groq API error")
        return {}

def filter_df_by_rules(df, rules):
    df_filtered = df.copy()
    for feature, condition in rules.items():
        if feature not in df.columns:
            continue

        condition = condition.replace("â€“", "-")
        if '-' in condition:
            try:
                low, high = map(float, condition.split('-'))
                df_filtered = df_filtered[(df_filtered[feature] >= low) & (df_filtered[feature] <= high)]
            except:
                continue
        elif '<' in condition:
            try:
                val = float(condition.replace('<', '').strip())
                df_filtered = df_filtered[df_filtered[feature] < val]
            except:
                continue
        elif '>' in condition:
            try:
                val = float(condition.replace('>', '').strip())
                df_filtered = df_filtered[df_filtered[feature] > val]
            except:
                continue
    return df_filtered

# Hybrid Filtering
def generate_hybrid_playlist_from_prompt(prompt, df, k=6, top_n=20):
    rules = get_feature_rules_from_prompt(prompt)
    user_history = filter_df_by_rules(df, rules)

    if user_history.empty or len(user_history) < 5:
        st.warning("Not enough songs matched the filter rules to build a playlist.")
        return pd.DataFrame()

    feature_cols = ['tempo', 'energy', 'valence', 'danceability', 'acousticness']
    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df[feature_cols])
    user_scaled = scaler.transform(user_history[feature_cols])

    # Content Based Filtering
    content_similarity = cosine_similarity(user_scaled, df_scaled).mean(axis=0)
    df['similarity'] = content_similarity

    # Collaborative Filtering
    knn_model = NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=k)
    knn_model.fit(df_scaled)

    collab_recs = []
    for song_vec in user_scaled:
        _, indices = knn_model.kneighbors([song_vec])
        collab_recs.extend(indices[0][1:])

    collab_scores = pd.Series(collab_recs).value_counts()
    df['collab_score'] = 0
    df.loc[collab_scores.index, 'collab_score'] = collab_scores.values

    df[['similarity', 'collab_score']] = scaler.fit_transform(df[['similarity', 'collab_score']])
    df['hybrid_score'] = (df['similarity'] + df['collab_score']) / 2

    hybrid_result = df[~df['track_name'].isin(user_history['track_name'])] \
                     .sort_values(by='hybrid_score', ascending=False) \
                     .head(top_n)

    return hybrid_result[['track_name', 'artists', 'track_genre', 'hybrid_score']]

# Streamlit App
st.title("ðŸŽ¶ AI-Generated Playlist Recommender")

st.subheader("ðŸ“‚ Your Playlists")
for name, playlist_df in user_playlists.items():
    with st.expander(f"{name} Playlist"):
        st.dataframe(playlist_df.reset_index(drop=True))

st.subheader("âœ¨ Generate a New Playlist")
prompt = st.text_input("Describe the kind of playlist you want:")

if prompt and GROQ_API_KEY:
    with st.spinner("Generating your playlist..."):
        playlist = generate_hybrid_playlist_from_prompt(prompt, df)
        if not playlist.empty:
            st.success("Here's your personalized playlist:")
            st.dataframe(playlist.reset_index(drop=True))
